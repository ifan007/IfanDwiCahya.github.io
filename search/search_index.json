{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang... \u00b6 NAMA : IFAN DWI CAHYA NIM : 180411100141 PRODI : TEKNIK INFORMATIKA FAKULTAS : TEKNIK UNIVERSITAS TRUNOJOYO MADURA KELAS : KOMPUTASI NUMERIK B","title":"Beranda"},{"location":"#selamat-datang","text":"NAMA : IFAN DWI CAHYA NIM : 180411100141 PRODI : TEKNIK INFORMATIKA FAKULTAS : TEKNIK UNIVERSITAS TRUNOJOYO MADURA KELAS : KOMPUTASI NUMERIK B","title":"Selamat Datang..."},{"location":"tugas1/","text":"DERET MACLAURIN \u00b6 Deret MacLaurin merupakan suatu fungsi f(x) yang memiliki turunan f'(x), f\u201d(x), f\u201d'(x), dan seterusnya yang kontinyu dalam interval I dan a, x I maka untuk x disekitar a yaitu |x \u2013 a| < , f(x) dapat diekspansi kedalam Deret Taylor. contoh Deret Maclaurin : $$ f(x) = f(0)+f'(0) \\frac{x}{1!}+f''(0) \\frac{x^2}{2!}+f'''(0) \\frac{x^3}{3!}+... $$ Soal \u00b6 tentukan e^2x dengan x = 4 dan ekspansi eror < 0,001. Penyelesaian \u00b6 Perhitungan e^2x Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. . Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. Untuk bilangan e2^x maka: cara perhitungannya adalah sebagai berikut: Jika nilai x diganti dengan 4 maka hasilnya adalah 296,99 Listing Program \u00b6 Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 hsl = 1 a = 0 b = 1 ulang = 1 while hsl > 0.001 : fx = 0 fy = 0 for i in range ( a ): fx += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): fy += ( 2 ** j ) * x ** j / math . factorial ( j ) hsl = fy - fx a += 1 b += 1 print ( \"perulangan ke\" , ulang , \"= \" , hsl ) ulang += 1 Output: perulangan ke 1 = 1.0 perulangan ke 2 = 8.0 perulangan ke 3 = 32.0 perulangan ke 4 = 85.33333333333333 perulangan ke 5 = 170.66666666666669 perulangan ke 6 = 273.0666666666666 perulangan ke 7 = 364.08888888888896 perulangan ke 8 = 416.1015873015872 perulangan ke 9 = 416.1015873015872 perulangan ke 10 = 369.8680776014112 perulangan ke 11 = 295.89446208112895 perulangan ke 12 = 215.195972422639 perulangan ke 13 = 143.46398161509296 perulangan ke 14 = 88.28552714774924 perulangan ke 15 = 50.448872655856576 perulangan ke 16 = 26.90606541645684 perulangan ke 17 = 13.45303270822842 perulangan ke 18 = 6.330838921519444 perulangan ke 19 = 2.8137061873417224 perulangan ke 20 = 1.184718394670199 perulangan ke 21 = 0.47388735786807956 perulangan ke 22 = 0.18052851728316455 perulangan ke 23 = 0.06564673355751438 perulangan ke 24 = 0.022833646454728296 perulangan ke 25 = 0.0076112154847578495 perulangan ke 26 = 0.0024355889549951826 perulangan ke 27 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Tugas 1"},{"location":"tugas1/#deret-maclaurin","text":"Deret MacLaurin merupakan suatu fungsi f(x) yang memiliki turunan f'(x), f\u201d(x), f\u201d'(x), dan seterusnya yang kontinyu dalam interval I dan a, x I maka untuk x disekitar a yaitu |x \u2013 a| < , f(x) dapat diekspansi kedalam Deret Taylor. contoh Deret Maclaurin : $$ f(x) = f(0)+f'(0) \\frac{x}{1!}+f''(0) \\frac{x^2}{2!}+f'''(0) \\frac{x^3}{3!}+... $$","title":"DERET MACLAURIN"},{"location":"tugas1/#soal","text":"tentukan e^2x dengan x = 4 dan ekspansi eror < 0,001.","title":"Soal"},{"location":"tugas1/#penyelesaian","text":"Perhitungan e^2x Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. . Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. Untuk bilangan e2^x maka: cara perhitungannya adalah sebagai berikut: Jika nilai x diganti dengan 4 maka hasilnya adalah 296,99","title":"Penyelesaian"},{"location":"tugas1/#listing-program","text":"Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 hsl = 1 a = 0 b = 1 ulang = 1 while hsl > 0.001 : fx = 0 fy = 0 for i in range ( a ): fx += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): fy += ( 2 ** j ) * x ** j / math . factorial ( j ) hsl = fy - fx a += 1 b += 1 print ( \"perulangan ke\" , ulang , \"= \" , hsl ) ulang += 1 Output: perulangan ke 1 = 1.0 perulangan ke 2 = 8.0 perulangan ke 3 = 32.0 perulangan ke 4 = 85.33333333333333 perulangan ke 5 = 170.66666666666669 perulangan ke 6 = 273.0666666666666 perulangan ke 7 = 364.08888888888896 perulangan ke 8 = 416.1015873015872 perulangan ke 9 = 416.1015873015872 perulangan ke 10 = 369.8680776014112 perulangan ke 11 = 295.89446208112895 perulangan ke 12 = 215.195972422639 perulangan ke 13 = 143.46398161509296 perulangan ke 14 = 88.28552714774924 perulangan ke 15 = 50.448872655856576 perulangan ke 16 = 26.90606541645684 perulangan ke 17 = 13.45303270822842 perulangan ke 18 = 6.330838921519444 perulangan ke 19 = 2.8137061873417224 perulangan ke 20 = 1.184718394670199 perulangan ke 21 = 0.47388735786807956 perulangan ke 22 = 0.18052851728316455 perulangan ke 23 = 0.06564673355751438 perulangan ke 24 = 0.022833646454728296 perulangan ke 25 = 0.0076112154847578495 perulangan ke 26 = 0.0024355889549951826 perulangan ke 27 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Listing Program"},{"location":"tugas2/","text":"Mencari Nilai Akar Dalam Persamaan Aljabar \u00b6 ada 4 metode dalam penyelesaian mencari nilai akar persamaan aljabar yaitu Metode Bisection Metode Regula- Falsi Metode Newton Raphson Metode Secant 1. Metode Bisection \u00b6 \u200b Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Dalam perhitungan mencari Nilai Akar dengen Metode Bisection Tentukan batas bawah (a) dan batas atas (b). Kemudian dihitung nilai tengah :$ x =a+b/2$ Dari nilai c ini perlu dilakukan pengecekan keberadaan akar. Secara matematik, suatu range terdapat akar persamaan bila f(a) dan f(b) berlawanan tanda atau dituliskan : f(a).f(b)<0 f(a).f(b)<0 Setelah diketahui di bagian mana terdapat akar, maka batas bawah dan batas atas diperbarui sesuai dengan range dari bagian yang mempunyai akar. Algoritma Mencari Akar dengan Motode Bisection \u00b6 Tentukan nilai a dan b Tentukan toleransi ee dan iterasi maksimum N Hitung f(a) f(a) dan f(b) f(b) Jika f(a).f(b)>0 f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x=(a+b)/2 x=(a+b)/2 Hitung f(x) f(x) Bila f(x).f(a)<0 f(x).f(a)<0 maka b=x b=x dan f(b)=f(x) f(b)=f(x) , bila tidak maka a=x a=x dan f(a)=f(x) f(a)=f(x) Jika |b\u2212a|<e |b\u2212a|<e , dimana ketika iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 langkah menghitung dengan menggunakan bisection \u00b6 Mendifinisikan sebuah fungsi f(x), dimana f(x) yang akan digunakan adalah : f(x)=x^2\u22125x+6 f(x)=x^2\u22125x+6 Langkah kedua menentukan Nilai a dan b, mengambil nilai batas awal (a) = 1 dan nilai batas bawahnya (b) = 2.1 Langkah ketiga menentukan toleransi tingkat error dan iterasi maksimum (N), pada langkah ini tolerasi tingkat error yang akan digunakan adalah 0,0001 dan iterasi maksimum yang digunakan adalah 40 Menghitung f(a) dan f(b) f(a)=1^2-5(1)+6= 2 f(a)=1^2-5(1)+6= 2 f(b)= 2,1^2 - 5(2,1)+6=-0.09 f(b)= 2,1^2 - 5(2,1)+6=-0.09 Mengecek dengan kondisi ketika f(a).f(b)>0 maka proses itu akan diberhentikan, bila f(a).f(b)<0 maka akan lanjut ke proses berikutnya. disini f(a).f(b)= 2 X -0.09 = -0.18 berarti f(a).f(b) < 0 Pada langkah ini menghitung x = (a+b)/2, dimana a =1 dan b = 2.1 maka x = (1+2.1)/2 = 1.55 Setelah mendapatkan nilai xx maka menghitung nilai f(x)nya dengan x=1.55 maka f(1.55)=(1.55)^2\u22125(1.55)+6=0,6525 f(1.55)=(1.55)^2\u22125(1.55)+6=0,6525 , maka didapatkan f(x)=0.6525 Melakukan pengecekan bila f(x).f(a)<0 maka b=x dan f(b)=f(x) jika sebaliknya maka a=x dan f(a)=f(x) f(x).f(a)= 1,305 < 0 maka a=x, jadi a=1,55 dan f(a)=1,55^2-5(1,55)+6= 0,6525 f(a)=1,55^2-5(1,55)+6= 0,6525 Maka Langkah berikutnya mengecek jika |b\u2212a|<e |b\u2212a|<e atau Iterasi sudah mencapai iterasi maksimum maka proses dihentikan dan mendapatkan akar yang dicari. |b-a|=|2,1-1,55|= 0.55 |b-a|=|2,1-1,55|= 0.55 dapat diketahui bahwa |b\u2212a| tidak < dari e maka terus melakukan iterasi sampai mendapatkan nilai akar yang dicari atau sudah sampai dengan iterasi maksimum Program mencari akar dengan metode bisection \u00b6 def f ( x ): return x ** 2 - 5 * x + 6 error = 0.0001 a = 1 b = 2.1 def bisection ( a , b ): iteration = True i = 0 max_iter = 50 while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a + b ) / 2 if f ( a ) * f ( x ) < 0 : b = x print ( \"Jika f(a)*f(x) < 0 maka b = x, b = \" , x ) if f ( b ) * f ( x ) < 0 : a = x print ( \"Jika f(b)*f(x) < 0 maka a = x, b = \" , x ) if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak ditemukan akar' ) print ( 'x =' , x ) bisection ( a , b ) output : Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.55 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.8250000000000002 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9625000000000001 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.03125 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9968750000000002 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0140625 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0054687500000004 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0011718750000003 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9990234375000002 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0000976562500004 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9995605468750002 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9998291015625003 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9999633789062503 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0000305175781254 x = 2.0000305175781254 2. Metode Regula falsi \u00b6 Algoritma Mencari Akar dengan Motode Regula-Falsi \u00b6 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Mengecek nilai f(a).f(b)<0f(a).f(b)<0 bila tidak maka proses nilai f(a).f(b)>0, akan memberhentikan proses perhitungan (program) 6.Mengkalkulasi x=(a|f(b)|+b|f(a)|/|f(a)|+|f(b)| x=(a|f(b)|+b|f(a)|/|f(a)|+|f(b)| 7.Jika f(a).f(x)<0 maka b = x, ketika tidak jika f(x).f(b)<0 maka a = x 8.Jika |b-a|< \u03b5, \u03b5 menjadi akurasi yang ditentukan. Lalu lanjutkan ke Langkah 9 yang lain Langkah 4 9.Cetak nilai x yang dibutuhkan akar Program mencari akar dengan regula falsi \u00b6 def f ( x ): return x ** 2 - 5 * x + 6 error = 0.0001 a = 1 b = 2.1 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x print ( \"Jika f(a) x f(x) < 0 , maka b = x , b = \" , x ) if f ( x ) * f ( b ) < 0 : a = x print ( \"Jika f(b) x f(x) < 0 , maka a = x , a = \" , x ) if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) output : Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0526315789473686 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.027027027027027 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.013698630136986 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0068965517241377 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0034602076124566 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0017331022530334 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000867302688638 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0004338394793924 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000216966804079 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000108495171965 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000542505289434 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000271260002713 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000135631840936 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000006781638037 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000033908305164 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000016954181326 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000008477097846 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000004238550715 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000002119275804 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000001059638013 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000529819038 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000264909525 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000013245477 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000066227384 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000033113694 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000001655685 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000008278422 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000413921 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000002069602 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000001034803 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000517404 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000258704 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000012935 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000064673 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000032334 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000001617 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000008087 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000004046 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000202 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000101 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.00000000000005 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000000253 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000013 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000000067 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000003 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000000013 x = 2.0000000000000004 3. Metode Newton Raphton \u00b6 Algoritma Mencari Akar dengan Motode Newton Raphson \u00b6 1.Definisikan fungsi f(x) , f'(x) yang akan dicari akarnya 2.Tentukan tebakan awal akarmisal x0 dan set n = 0 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung xn+1=xn\u2212[f(xn)/f\u2032(x)n] 5.Jika |xn+1\u2212xn|<e , di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 7, bila lanjut ke langkah 6 6.Set n = n+1 dan pergi ke langkah 4 7.Cetak nilai xn yang merupakan nilai akar yang diperlukan Program mencari akar dengan metode newton raphton \u00b6 def f ( x ): return x ** 2 - 5 * x + 6 def f_turunan ( x ): return 2 * x - 5 error = 0.0001 x0 = 0 def newton_raphson ( x0 ): iterasi = True n = 0 x_next = x0 print ( \"X0 =\" , x_next ) while iterasi : x_x = x_next x_next = x_x - ( f ( x_x ) / f_turunan ( x_x )) print ( \"x_(\" , n + 1 , \") = \" , x_next ) if abs ( x_next - x_x ) < error : iterasi = False else : n += 1 print ( \"x = \" , x_next ) newton_raphson ( x0 ) output : X0 = 0 x_ ( 1 ) = 1.2 x_ ( 2 ) = 1.7538461538461536 x_ ( 3 ) = 1.9593973037272008 x_ ( 4 ) = 1.9984752398055106 x_ ( 5 ) = 1.9999976821746035 x_ ( 6 ) = 1.9999999999946272 x = 1.9999999999946272 4. Metode Secant \u00b6 Algoritma Mencari Akar dengan Motode Secant \u00b6 Definisikan fungsi f(x) yang akan dicari akarnya Masukkan interval a, b dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi e dan iterasi maksimum N Hitung f(a) dan f(b) Menghitung x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a) Jika |a\u2212b|<e, di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 8, bila tidak lanjut ke langkah 7 Set a = b , b =x dan pergi ke langkah ke 4 Cetak nilai x yang merupakan nilai akar yang dicari. Program mencari akar dengan metode secant \u00b6 def f ( x ): return x ** 2 - 5 * x + 6 error = 0.0001 a = 1 b = 2.1 def secant ( a , b ): iterasi = True while iterasi : x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) print ( 'x = a - ((b-a) / (f(b) - f(a))) * f(a)= ' , x ) if abs ( a - b ) < error : iterasi = False else : a = b print ( \"set a = b maka a = \" , b ) b = x print ( \"set b = x maka b = \" , x ) print ( 'x =' , x ) secant ( a , b ) Output: x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.0526315789473686 set a = b maka a = 2.1 set b = x maka b = 2.0526315789473686 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 1.9937888198757765 set a = b maka a = 2.0526315789473686 set b = x maka b = 1.9937888198757765 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.000342817963662 set a = b maka a = 1.9937888198757765 set b = x maka b = 2.000342817963662 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.0000021168814945 set a = b maka a = 2.000342817963662 set b = x maka b = 2.0000021168814945 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 1.9999999992740438 set a = b maka a = 2.0000021168814945 set b = x maka b = 1.9999999992740438 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.0000000000000013 x = 2.0000000000000013","title":"Tugas 2"},{"location":"tugas2/#mencari-nilai-akar-dalam-persamaan-aljabar","text":"ada 4 metode dalam penyelesaian mencari nilai akar persamaan aljabar yaitu Metode Bisection Metode Regula- Falsi Metode Newton Raphson Metode Secant","title":"Mencari Nilai Akar Dalam Persamaan Aljabar"},{"location":"tugas2/#1-metode-bisection","text":"\u200b Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Dalam perhitungan mencari Nilai Akar dengen Metode Bisection Tentukan batas bawah (a) dan batas atas (b). Kemudian dihitung nilai tengah :$ x =a+b/2$ Dari nilai c ini perlu dilakukan pengecekan keberadaan akar. Secara matematik, suatu range terdapat akar persamaan bila f(a) dan f(b) berlawanan tanda atau dituliskan : f(a).f(b)<0 f(a).f(b)<0 Setelah diketahui di bagian mana terdapat akar, maka batas bawah dan batas atas diperbarui sesuai dengan range dari bagian yang mempunyai akar.","title":"1. Metode Bisection"},{"location":"tugas2/#algoritma-mencari-akar-dengan-motode-bisection","text":"Tentukan nilai a dan b Tentukan toleransi ee dan iterasi maksimum N Hitung f(a) f(a) dan f(b) f(b) Jika f(a).f(b)>0 f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x=(a+b)/2 x=(a+b)/2 Hitung f(x) f(x) Bila f(x).f(a)<0 f(x).f(a)<0 maka b=x b=x dan f(b)=f(x) f(b)=f(x) , bila tidak maka a=x a=x dan f(a)=f(x) f(a)=f(x) Jika |b\u2212a|<e |b\u2212a|<e , dimana ketika iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6","title":"Algoritma Mencari Akar dengan Motode Bisection"},{"location":"tugas2/#langkah-menghitung-dengan-menggunakan-bisection","text":"Mendifinisikan sebuah fungsi f(x), dimana f(x) yang akan digunakan adalah : f(x)=x^2\u22125x+6 f(x)=x^2\u22125x+6 Langkah kedua menentukan Nilai a dan b, mengambil nilai batas awal (a) = 1 dan nilai batas bawahnya (b) = 2.1 Langkah ketiga menentukan toleransi tingkat error dan iterasi maksimum (N), pada langkah ini tolerasi tingkat error yang akan digunakan adalah 0,0001 dan iterasi maksimum yang digunakan adalah 40 Menghitung f(a) dan f(b) f(a)=1^2-5(1)+6= 2 f(a)=1^2-5(1)+6= 2 f(b)= 2,1^2 - 5(2,1)+6=-0.09 f(b)= 2,1^2 - 5(2,1)+6=-0.09 Mengecek dengan kondisi ketika f(a).f(b)>0 maka proses itu akan diberhentikan, bila f(a).f(b)<0 maka akan lanjut ke proses berikutnya. disini f(a).f(b)= 2 X -0.09 = -0.18 berarti f(a).f(b) < 0 Pada langkah ini menghitung x = (a+b)/2, dimana a =1 dan b = 2.1 maka x = (1+2.1)/2 = 1.55 Setelah mendapatkan nilai xx maka menghitung nilai f(x)nya dengan x=1.55 maka f(1.55)=(1.55)^2\u22125(1.55)+6=0,6525 f(1.55)=(1.55)^2\u22125(1.55)+6=0,6525 , maka didapatkan f(x)=0.6525 Melakukan pengecekan bila f(x).f(a)<0 maka b=x dan f(b)=f(x) jika sebaliknya maka a=x dan f(a)=f(x) f(x).f(a)= 1,305 < 0 maka a=x, jadi a=1,55 dan f(a)=1,55^2-5(1,55)+6= 0,6525 f(a)=1,55^2-5(1,55)+6= 0,6525 Maka Langkah berikutnya mengecek jika |b\u2212a|<e |b\u2212a|<e atau Iterasi sudah mencapai iterasi maksimum maka proses dihentikan dan mendapatkan akar yang dicari. |b-a|=|2,1-1,55|= 0.55 |b-a|=|2,1-1,55|= 0.55 dapat diketahui bahwa |b\u2212a| tidak < dari e maka terus melakukan iterasi sampai mendapatkan nilai akar yang dicari atau sudah sampai dengan iterasi maksimum","title":"langkah menghitung dengan menggunakan bisection"},{"location":"tugas2/#program-mencari-akar-dengan-metode-bisection","text":"def f ( x ): return x ** 2 - 5 * x + 6 error = 0.0001 a = 1 b = 2.1 def bisection ( a , b ): iteration = True i = 0 max_iter = 50 while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a + b ) / 2 if f ( a ) * f ( x ) < 0 : b = x print ( \"Jika f(a)*f(x) < 0 maka b = x, b = \" , x ) if f ( b ) * f ( x ) < 0 : a = x print ( \"Jika f(b)*f(x) < 0 maka a = x, b = \" , x ) if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak ditemukan akar' ) print ( 'x =' , x ) bisection ( a , b ) output : Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.55 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.8250000000000002 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9625000000000001 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.03125 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9968750000000002 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0140625 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0054687500000004 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0011718750000003 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9990234375000002 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0000976562500004 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9995605468750002 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9998291015625003 Jika f ( b ) * f ( x ) < 0 maka a = x , b = 1.9999633789062503 Jika f ( a ) * f ( x ) < 0 maka b = x , b = 2.0000305175781254 x = 2.0000305175781254","title":"Program mencari akar dengan metode bisection"},{"location":"tugas2/#2-metode-regula-falsi","text":"","title":"2. Metode Regula falsi"},{"location":"tugas2/#algoritma-mencari-akar-dengan-motode-regula-falsi","text":"1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Mengecek nilai f(a).f(b)<0f(a).f(b)<0 bila tidak maka proses nilai f(a).f(b)>0, akan memberhentikan proses perhitungan (program) 6.Mengkalkulasi x=(a|f(b)|+b|f(a)|/|f(a)|+|f(b)| x=(a|f(b)|+b|f(a)|/|f(a)|+|f(b)| 7.Jika f(a).f(x)<0 maka b = x, ketika tidak jika f(x).f(b)<0 maka a = x 8.Jika |b-a|< \u03b5, \u03b5 menjadi akurasi yang ditentukan. Lalu lanjutkan ke Langkah 9 yang lain Langkah 4 9.Cetak nilai x yang dibutuhkan akar","title":"Algoritma Mencari Akar dengan Motode Regula-Falsi"},{"location":"tugas2/#program-mencari-akar-dengan-regula-falsi","text":"def f ( x ): return x ** 2 - 5 * x + 6 error = 0.0001 a = 1 b = 2.1 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x print ( \"Jika f(a) x f(x) < 0 , maka b = x , b = \" , x ) if f ( x ) * f ( b ) < 0 : a = x print ( \"Jika f(b) x f(x) < 0 , maka a = x , a = \" , x ) if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) output : Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0526315789473686 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.027027027027027 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.013698630136986 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0068965517241377 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0034602076124566 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0017331022530334 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000867302688638 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0004338394793924 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000216966804079 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000108495171965 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000542505289434 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000271260002713 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000135631840936 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000006781638037 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000033908305164 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000016954181326 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000008477097846 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000004238550715 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000002119275804 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000001059638013 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000529819038 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000264909525 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000013245477 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000066227384 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000033113694 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000001655685 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000008278422 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000413921 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000002069602 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000001034803 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000517404 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000258704 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000012935 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000064673 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000032334 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000001617 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000008087 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000004046 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000202 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000101 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.00000000000005 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000000253 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000013 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000000067 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.000000000000003 Jika f ( a ) x f ( x ) < 0 , maka b = x , b = 2.0000000000000013 x = 2.0000000000000004","title":"Program mencari akar dengan regula falsi"},{"location":"tugas2/#3-metode-newton-raphton","text":"","title":"3. Metode Newton Raphton"},{"location":"tugas2/#algoritma-mencari-akar-dengan-motode-newton-raphson","text":"1.Definisikan fungsi f(x) , f'(x) yang akan dicari akarnya 2.Tentukan tebakan awal akarmisal x0 dan set n = 0 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung xn+1=xn\u2212[f(xn)/f\u2032(x)n] 5.Jika |xn+1\u2212xn|<e , di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 7, bila lanjut ke langkah 6 6.Set n = n+1 dan pergi ke langkah 4 7.Cetak nilai xn yang merupakan nilai akar yang diperlukan","title":"Algoritma Mencari Akar dengan Motode Newton Raphson"},{"location":"tugas2/#program-mencari-akar-dengan-metode-newton-raphton","text":"def f ( x ): return x ** 2 - 5 * x + 6 def f_turunan ( x ): return 2 * x - 5 error = 0.0001 x0 = 0 def newton_raphson ( x0 ): iterasi = True n = 0 x_next = x0 print ( \"X0 =\" , x_next ) while iterasi : x_x = x_next x_next = x_x - ( f ( x_x ) / f_turunan ( x_x )) print ( \"x_(\" , n + 1 , \") = \" , x_next ) if abs ( x_next - x_x ) < error : iterasi = False else : n += 1 print ( \"x = \" , x_next ) newton_raphson ( x0 ) output : X0 = 0 x_ ( 1 ) = 1.2 x_ ( 2 ) = 1.7538461538461536 x_ ( 3 ) = 1.9593973037272008 x_ ( 4 ) = 1.9984752398055106 x_ ( 5 ) = 1.9999976821746035 x_ ( 6 ) = 1.9999999999946272 x = 1.9999999999946272","title":"Program mencari akar dengan metode newton raphton"},{"location":"tugas2/#4-metode-secant","text":"","title":"4. Metode Secant"},{"location":"tugas2/#algoritma-mencari-akar-dengan-motode-secant","text":"Definisikan fungsi f(x) yang akan dicari akarnya Masukkan interval a, b dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi e dan iterasi maksimum N Hitung f(a) dan f(b) Menghitung x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a) Jika |a\u2212b|<e, di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 8, bila tidak lanjut ke langkah 7 Set a = b , b =x dan pergi ke langkah ke 4 Cetak nilai x yang merupakan nilai akar yang dicari.","title":"Algoritma Mencari Akar dengan Motode Secant"},{"location":"tugas2/#program-mencari-akar-dengan-metode-secant","text":"def f ( x ): return x ** 2 - 5 * x + 6 error = 0.0001 a = 1 b = 2.1 def secant ( a , b ): iterasi = True while iterasi : x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) print ( 'x = a - ((b-a) / (f(b) - f(a))) * f(a)= ' , x ) if abs ( a - b ) < error : iterasi = False else : a = b print ( \"set a = b maka a = \" , b ) b = x print ( \"set b = x maka b = \" , x ) print ( 'x =' , x ) secant ( a , b ) Output: x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.0526315789473686 set a = b maka a = 2.1 set b = x maka b = 2.0526315789473686 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 1.9937888198757765 set a = b maka a = 2.0526315789473686 set b = x maka b = 1.9937888198757765 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.000342817963662 set a = b maka a = 1.9937888198757765 set b = x maka b = 2.000342817963662 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.0000021168814945 set a = b maka a = 2.000342817963662 set b = x maka b = 2.0000021168814945 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 1.9999999992740438 set a = b maka a = 2.0000021168814945 set b = x maka b = 1.9999999992740438 x = a - (( b - a ) / ( f ( b ) - f ( a ))) * f ( a ) = 2.0000000000000013 x = 2.0000000000000013","title":"Program mencari akar dengan metode secant"},{"location":"tugas3/","text":"Eliminasi Gauss Jordan \u00b6 \u00b6 Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 \u00b6 \u00b6 \u00b6 Listing Program \u00b6 \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 \u00b6 Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 \u00b6 from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 \u00b6 Listing Program \u00b6 \u00b6 def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Tugas 3"},{"location":"tugas3/#eliminasi-gauss-jordan","text":"Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan\u00b6"},{"location":"tugas3/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan\u00b6"},{"location":"tugas3/#_1","text":"","title":"\u00b6"},{"location":"tugas3/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program\u00b6"},{"location":"tugas3/#eliminasi-gauss-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi\u00b6"},{"location":"tugas3/#listing-program_1","text":"from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program\u00b6"},{"location":"tugas3/#program-gauss-seidel","text":"","title":"Program Gauss Seidel\u00b6"},{"location":"tugas3/#listing-program_2","text":"def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Listing Program\u00b6"},{"location":"tugas4/","text":"Integrasi Numeric \u00b6 Integration \u00b6 Integral tak tentu Integral tak tentu adalah suatu fungsi yang berbeda satu sama lain oleh konstanta integral tertentu Integral tertentu adalah suatu bilangan teori dasar kalkulus \u00b6 Metode Newton-Cotes \u00b6 Metode Trapezoid \u00b6 Metode Recursive Trapezoid \u00b6 Metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja. Maka dapat dituliskan persamaan sebagai berikut : Listing Program \u00b6 #Mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus yang digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Inputkan batas bawah : \" )) b = float ( input ( \"Masukkan batas atas : \" )) c = int ( input ( \"Masukkan n : \" )) error = [] print ( \" \" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil ) Outputnya yaitu : \u00b6 Rumus yang digunakan adalah = f ( x ) = 1 / ( 1 + x ) Inputkan batas bawah : 2 Masukkan batas atas : 4 Masukkan n : 7 1 1 0.5333333333333333 2 2 0.5166666666666666 3 4 0.5123015873015873 4 8 0.5111956455996705 5 16 0.5109181945162025 6 32 0.5108487705480642 7 64 0.5108314107176335 0.5108487705480642 0.5108314107176335 estimasi error = 1.735983043071876e-05 Metode romberg \u00b6","title":"Tugas 4"},{"location":"tugas4/#integrasi-numeric","text":"","title":"Integrasi Numeric"},{"location":"tugas4/#integration","text":"Integral tak tentu Integral tak tentu adalah suatu fungsi yang berbeda satu sama lain oleh konstanta integral tertentu Integral tertentu adalah suatu bilangan","title":"Integration"},{"location":"tugas4/#teori-dasar-kalkulus","text":"","title":"teori dasar kalkulus"},{"location":"tugas4/#metode-newton-cotes","text":"","title":"Metode Newton-Cotes"},{"location":"tugas4/#metode-trapezoid","text":"","title":"Metode Trapezoid"},{"location":"tugas4/#metode-recursive-trapezoid","text":"Metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja. Maka dapat dituliskan persamaan sebagai berikut :","title":"Metode Recursive Trapezoid"},{"location":"tugas4/#listing-program","text":"#Mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus yang digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Inputkan batas bawah : \" )) b = float ( input ( \"Masukkan batas atas : \" )) c = int ( input ( \"Masukkan n : \" )) error = [] print ( \" \" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil )","title":"Listing Program"},{"location":"tugas4/#outputnya-yaitu","text":"Rumus yang digunakan adalah = f ( x ) = 1 / ( 1 + x ) Inputkan batas bawah : 2 Masukkan batas atas : 4 Masukkan n : 7 1 1 0.5333333333333333 2 2 0.5166666666666666 3 4 0.5123015873015873 4 8 0.5111956455996705 5 16 0.5109181945162025 6 32 0.5108487705480642 7 64 0.5108314107176335 0.5108487705480642 0.5108314107176335 estimasi error = 1.735983043071876e-05","title":"Outputnya yaitu :"},{"location":"tugas4/#metode-romberg","text":"","title":"Metode romberg"},{"location":"tugas5/","text":"Richardson Extrapolation \u00b6 Tabel Richardson Extrapolation \u00b6 D(0,0)=\u03a6(h) D(1,0)=\u03a6(h/2) D(1,1) D(2,0)=\u03a6(h/4) D(2,1) D(2,2) D(3,0)=\u03a6(h/8) D(3,1) D(3,2) D(3,3) Program Richardson Extrapolation \u00b6 from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): '''Richardson extrapolation method for numerical calculation of first derivative ''' k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'Numerical differentiation of Func=-0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 at x=0.5' ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) at x=pi/2 is equal to = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) Output : Numerical differentiation of Func =- 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 at x = 0.5 - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) at x = pi / 2 is equal to = 0.16849558398154249050","title":"Tugas 5"},{"location":"tugas5/#richardson-extrapolation","text":"","title":"Richardson Extrapolation"},{"location":"tugas5/#tabel-richardson-extrapolation","text":"D(0,0)=\u03a6(h) D(1,0)=\u03a6(h/2) D(1,1) D(2,0)=\u03a6(h/4) D(2,1) D(2,2) D(3,0)=\u03a6(h/8) D(3,1) D(3,2) D(3,3)","title":"Tabel Richardson Extrapolation"},{"location":"tugas5/#program-richardson-extrapolation","text":"from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): '''Richardson extrapolation method for numerical calculation of first derivative ''' k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'Numerical differentiation of Func=-0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 at x=0.5' ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) at x=pi/2 is equal to = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) Output : Numerical differentiation of Func =- 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 at x = 0.5 - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) at x = pi / 2 is equal to = 0.16849558398154249050","title":"Program Richardson Extrapolation"},{"location":"tugas6/","text":"Metode Euler \u00b6 Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini merupakan metode yang paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah dalam pemahamannya sehingga memudahkan dalam mempelajari metode lain yang lebih teliti. Metode euler atau disebut juga metode orde pertama karena persamaannya kita hanya mengambil sampai suku orde pertama saja. Misalnya diberikan Persamaan Diferensial Biasa orde satu, y=dy/dx=f(x,y) y=dy/dx=f(x,y) dan nilai awal y(x0)=y0 y(x0)=y0 Dengan langkah h didefinisikan sebagai h=xn+1\u2212xn h=xn+1\u2212xn Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis yn+1=yn+hx f(xn,yn) yn+1=yn+hx f(xn,yn) Contoh: Gunakan metode Euler untuk menyelesaikan Persamaan Diferensial Biasa: dy/dx= 1+x^2, y(1)=\u22124 dy/dx= 1+x^2, y(1)=\u22124 Untuk menentukan y(1.01), y(1.02) dan y(1.03). program import numpy as np #Parameter untuk Euler y0 = - 4 x0 = float ( input ( \"masukkan nilai x0 :\" )) n = 4 h = 0.01 y = 0 hasil = y0 #Metode Euler for i in range ( 1 , n ): hasil = y0 + h * ( 1 + ( x0 ) ** 2 ) x0 += h y0 = hasil print ( \"Langkah\" + str ( i ) + \": y\" + str ( i ) + \"= \" + str ( hasil )) Output : masukkan nilai x0 : 1 Langkah1 : y1 = - 3.98 Langkah2 : y2 = - 3.959799 Langkah3 : y3 = - 3.9393949999999998 Process finished with exit code 0","title":"Tugas 6"},{"location":"tugas6/#metode-euler","text":"Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini merupakan metode yang paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah dalam pemahamannya sehingga memudahkan dalam mempelajari metode lain yang lebih teliti. Metode euler atau disebut juga metode orde pertama karena persamaannya kita hanya mengambil sampai suku orde pertama saja. Misalnya diberikan Persamaan Diferensial Biasa orde satu, y=dy/dx=f(x,y) y=dy/dx=f(x,y) dan nilai awal y(x0)=y0 y(x0)=y0 Dengan langkah h didefinisikan sebagai h=xn+1\u2212xn h=xn+1\u2212xn Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis yn+1=yn+hx f(xn,yn) yn+1=yn+hx f(xn,yn) Contoh: Gunakan metode Euler untuk menyelesaikan Persamaan Diferensial Biasa: dy/dx= 1+x^2, y(1)=\u22124 dy/dx= 1+x^2, y(1)=\u22124 Untuk menentukan y(1.01), y(1.02) dan y(1.03). program import numpy as np #Parameter untuk Euler y0 = - 4 x0 = float ( input ( \"masukkan nilai x0 :\" )) n = 4 h = 0.01 y = 0 hasil = y0 #Metode Euler for i in range ( 1 , n ): hasil = y0 + h * ( 1 + ( x0 ) ** 2 ) x0 += h y0 = hasil print ( \"Langkah\" + str ( i ) + \": y\" + str ( i ) + \"= \" + str ( hasil )) Output : masukkan nilai x0 : 1 Langkah1 : y1 = - 3.98 Langkah2 : y2 = - 3.959799 Langkah3 : y3 = - 3.9393949999999998 Process finished with exit code 0","title":"Metode Euler"},{"location":"tugas7/","text":"Monte Carlo Method \u00b6 \u200b Metode Monte Carlo digunakan dengan istilah sampling statistik. Penggunaan metode Monte Carlo memerlukan sejumlah besar bilangan acak, dan hal tersebut semakin mudah dengan perkembangan pembangkit bilangan pseudoacak, yang jauh lebih cepat dan praktis dibandingkan dengan metode sebelumnya yang menggunakan tabel bilangan acak untuk sampling statistik. \u200b Metode Monte Carlo adalah algoritme komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit. \u200b Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. \u200b Algoritme Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya. SOAL \u00b6 \u00b6 LISTING PROGRAM NO.3 \u00b6 from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func ( x ): return ( 4 - x ** 2 ) ** 0.5 area = [] for i in range ( N ): xrand = np . zeros ( N ) for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) integral = 0.0 for i in range ( N ): integral += func ( xrand [ i ]) jawab = ( b - a ) / float ( N ) * integral area . append ( jawab ) plt . title ( \"Nilai phi\" ) plt . hist ( area , bins = 30 , ec = 'black' ) plt . xlabel ( \"Area\" ) plt . show () Percobaan Pertama \u00b6 phi menunjukkan x=3.14465 dan y=255.824 Percobaan Kedua \u00b6 phi menunjukkan x=3.14118 dan y=286.82 Percobaan Ketiga \u00b6 phi menunjukkan x= 3.13834 dan y= 245.591 Listing Program No.4 \u00b6 from scipy import random #import library random dari scipy import numpy as np #import library numpy a = - 1 b = 1 N = 100 n = 3 xrand = np . zeros ( N ) #dx yrand = np . zeros ( N ) #dy zrand = np . zeros ( N ) #dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral = 0.0 for i in range ( n + 1 ): for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) for i in range ( len ( yrand )): yrand [ i ] = random . uniform ( a , b ) for i in range ( len ( zrand )): zrand [ i ] = random . uniform ( a , b ) def func ( x , y , z ): return ( x ** 2 ) + ( y ** 2 ) + ( z ** 2 ) for i in range ( N ): integral += func ( xrand [ i ], yrand [ i ], zrand [ i ]) jwb = ( b - a ) / float ( N ) * integral print ( \"Hasil : \" , jwb ) Output \u00b6 #Percobaan 1 C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.889285659898637 Process finished with exit code 0 #Percobaan 2 C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 8.02539169028922 Process finished with exit code 0 #Percobaan 3 C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.900022095053624 Process finished with exit code 0","title":"Tugas 7"},{"location":"tugas7/#monte-carlo-method","text":"\u200b Metode Monte Carlo digunakan dengan istilah sampling statistik. Penggunaan metode Monte Carlo memerlukan sejumlah besar bilangan acak, dan hal tersebut semakin mudah dengan perkembangan pembangkit bilangan pseudoacak, yang jauh lebih cepat dan praktis dibandingkan dengan metode sebelumnya yang menggunakan tabel bilangan acak untuk sampling statistik. \u200b Metode Monte Carlo adalah algoritme komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit. \u200b Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. \u200b Algoritme Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya.","title":"Monte Carlo Method"},{"location":"tugas7/#soal","text":"","title":"SOAL"},{"location":"tugas7/#_1","text":"","title":""},{"location":"tugas7/#listing-program-no3","text":"from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func ( x ): return ( 4 - x ** 2 ) ** 0.5 area = [] for i in range ( N ): xrand = np . zeros ( N ) for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) integral = 0.0 for i in range ( N ): integral += func ( xrand [ i ]) jawab = ( b - a ) / float ( N ) * integral area . append ( jawab ) plt . title ( \"Nilai phi\" ) plt . hist ( area , bins = 30 , ec = 'black' ) plt . xlabel ( \"Area\" ) plt . show ()","title":"LISTING PROGRAM NO.3"},{"location":"tugas7/#percobaan-pertama","text":"phi menunjukkan x=3.14465 dan y=255.824","title":"Percobaan Pertama"},{"location":"tugas7/#percobaan-kedua","text":"phi menunjukkan x=3.14118 dan y=286.82","title":"Percobaan Kedua"},{"location":"tugas7/#percobaan-ketiga","text":"phi menunjukkan x= 3.13834 dan y= 245.591","title":"Percobaan Ketiga"},{"location":"tugas7/#listing-program-no4","text":"from scipy import random #import library random dari scipy import numpy as np #import library numpy a = - 1 b = 1 N = 100 n = 3 xrand = np . zeros ( N ) #dx yrand = np . zeros ( N ) #dy zrand = np . zeros ( N ) #dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral = 0.0 for i in range ( n + 1 ): for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) for i in range ( len ( yrand )): yrand [ i ] = random . uniform ( a , b ) for i in range ( len ( zrand )): zrand [ i ] = random . uniform ( a , b ) def func ( x , y , z ): return ( x ** 2 ) + ( y ** 2 ) + ( z ** 2 ) for i in range ( N ): integral += func ( xrand [ i ], yrand [ i ], zrand [ i ]) jwb = ( b - a ) / float ( N ) * integral print ( \"Hasil : \" , jwb )","title":"Listing Program No.4"},{"location":"tugas7/#output","text":"#Percobaan 1 C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.889285659898637 Process finished with exit code 0 #Percobaan 2 C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 8.02539169028922 Process finished with exit code 0 #Percobaan 3 C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.900022095053624 Process finished with exit code 0","title":"Output"}]}